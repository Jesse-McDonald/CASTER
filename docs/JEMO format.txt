The JEMO (J Electron Microscopy Overlay) is designed to store the overlay data created by test_environment EMImage class.

The file contains a 2-part header, the first part is 4 bytes long and contains the letters J E M O in that order (4A 45 4D 4F) to describe the file type, (there is no null terminator) followed by a 1 byte version number for the file type

Version 0:
The second part of the header is 16 bytes long with 4 4 byte integers, while the integers are technically signed, they should never be negative so treat them as unsigned the integers are in big endian with the low byte being the last.  The first integer is the layer the save was taken on, this can be ignored but it allows the program to immediately resume the last layer, this should not be larger than the image depth, the second number is the width in pixels of each layer of the overlay, third is the height in pixels of each layer of the overlay, lastly is the depth, the number of layers there are in the image.  The remainder of the file is uncompressed pixel colors, there should be width*height*depth*4 remaining bytes.  each pixel is divided in to 4 bytes, 1 for each color of ARGB in that order (alpha is the first byte, blue is the last) the pixels start from the top left pixel on the 0 layer and move horizontally across the screen until there are [width] of them and then start a new line, when there are [height] lines, the next layer starts at the top left, and so on until the last layer is finished.

Version 1:
All integers are 4 bytes unless otherwise stated and they are unsigned stored with big endian low byte being last.
The second part of the header is 32 bytes long with first 16 bytes corisponding to the UUID of the project that original saved the file, this is stored in big endian with the low byte being last.
This should be used to validate that the correct project is opening the file, this is not strict, but a warning should be shown
the second 16 bytes are 4 4 byte integers, while the integers are technically signed, they should never be negative so treat them as unsigned.  The first integer is the layer the save was taken on, this can be ignored but it allows the program to immediately resume the last layer, this should not be larger than the image depth, the second number is the width in pixels of each layer of the overlay, third is the height in pixels of each layer of the overlay, lastly is the depth, the number of layers there are in the image.  
Emediatly following the header is an array of colors each 4 bytes long, each color divided in to 4 bytes, 1 for each color of ARGB in that order (alpha is the first byte, blue is the last).
This array ends at (but also includes) the color 0 0 0 0.  This array is inversly indexed so the color 0 0 0 0 is at index 0 and all other colors count up from there as you go towards the begining of the file.  (its handy to have the null color also be the null terminator).  This is the color palette.
Emediatly following this array is the data for the pixels is an integer representing the first nonblank layer.  This is followed by the first non blank layer

Each layer starts with a positive 4 byte integer, this integer is the index (left to right, then top to bottom) of the first non 0 pixel.  After that number is the first non 0 pixel.
The pixels are formatted with a positive 1-4 byte integer depending on the length of the collor pallet array, the number represents the index (starting at 0) of the colors.  Following the color is a 2 byte integer representing how many of the following pixels are that color.  Following that is the next colored pixel.
A layer ends emediatly if the color and length are both 0.  The file ends after the last layer is finished, or after a layer where the start index is 0, and is emediatly followed by a layer terminator.  To avoid accidential termination on fluke blank layers, any blank layer that is not the end of the file will be stored with an index greater than 0 followed by a layer terminator.